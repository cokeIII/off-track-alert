import { Observable } from 'tns-core-modules/data/observable/observable';
export declare class BluetoothUtil {
    static debug: boolean;
}
export declare enum CLogTypes {
    info = 0,
    warning = 1,
    error = 2,
}
export declare const CLog: (type?: CLogTypes, ...args: any[]) => void;
export declare function bluetoothEnabled(target: Object, propertyKey: string, descriptor: TypedPropertyDescriptor<any>): TypedPropertyDescriptor<any>;
export declare class BluetoothCommon extends Observable {
    debug: boolean;
    static msg_not_enabled: string;
    static msg_not_supported: string;
    static msg_cant_open_settings: string;
    static msg_missing_parameter: string;
    static msg_no_peripheral: string;
    static msg_no_service: string;
    static msg_no_characteristic: string;
    static msg_peripheral_not_connected: string;
    static msg_invalid_value: string;
    static msg_error_function_call: string;
    static msg_characteristic_cant_notify: string;
    static error_event: string;
    static bluetooth_status_event: string;
    static bluetooth_enabled_event: string;
    static bluetooth_discoverable_event: string;
    static bluetooth_advertise_success_event: string;
    static bluetooth_advertise_failure_event: string;
    static server_connection_state_changed_event: string;
    static bond_status_change_event: string;
    static device_discovered_event: string;
    static device_name_change_event: string;
    static device_uuid_change_event: string;
    static device_acl_disconnected_event: string;
    static characteristic_write_request_event: string;
    static characteristic_read_request_event: string;
    static descriptor_write_request_event: string;
    static descriptor_read_request_event: string;
    static execute_write_event: string;
    events: any;
    requestCoarseLocationPermission(): Promise<{}>;
    hasCoarseLocationPermission(): Promise<{}>;
    sendEvent(eventName: string, data?: any, msg?: string): void;
}
export declare enum ScanMode {
    LOW_LATENCY = 0,
    BALANCED = 1,
    LOW_POWER = 2,
    OPPORTUNISTIC = 3,
}
export declare enum MatchMode {
    AGGRESSIVE = 0,
    STICKY = 1,
}
export declare enum MatchNum {
    MAX_ADVERTISEMENT = 0,
    FEW_ADVERTISEMENT = 1,
    ONE_ADVERTISEMENT = 2,
}
export declare enum CallbackType {
    ALL_MATCHES = 0,
    FIRST_MATCH = 1,
    MATCH_LOST = 2,
}
export declare enum Phy {
    LE_1M = 0,
    LE_CODED = 1,
    LE_ALL_SUPPORTED = 2,
}
export declare type ConnectionState = 'connected' | 'connecting' | 'disconnected';
export interface StartScanningOptions {
    filters?: Array<{
        serviceUUID?: string;
        deviceName?: string;
        deviceAddress?: string;
        manufacturerData?: ArrayBuffer;
    }>;
    seconds?: number;
    onDiscovered?: (data: Peripheral) => void;
    skipPermissionCheck?: boolean;
    android?: {
        scanMode?: ScanMode;
        matchMode?: MatchMode;
        matchNum?: MatchNum;
        callbackType?: CallbackType;
        legacy?: boolean;
        useHardwareBatchingIfSupported?: boolean;
        reportDelay?: number;
        phy?: Phy;
    };
}
export interface DisconnectOptions {
    UUID: string;
}
export interface ConnectOptions {
    UUID: string;
    onConnected: (data: {
        UUID;
        name: string;
        state: ConnectionState;
        services: any[];
        advertismentData: AdvertismentData;
    }) => void;
    onDisconnected: (data: {
        UUID;
        name: string;
    }) => void;
}
export interface AdvertismentData {
    localName?: string;
    manufacturerData?: ArrayBuffer;
    manufacturerId?: number;
    serviceUUIDs?: string[];
    serviceData?: {
        [k: string]: ArrayBuffer;
    };
    txPowerLevel?: number;
    flags?: number;
}
export interface Peripheral {
    UUID: string;
    name: string;
    localName?: string;
    RSSI: number;
    services?: Service[];
    manufacturerId?: number;
    advertismentData?: AdvertismentData;
}
export interface Service {
    UUID: string;
    name?: string;
    characteristics: Characteristic[];
}
export interface Characteristic {
    UUID: string;
    name: string;
    properties: {
        read: boolean;
        write: boolean;
        writeWithoutResponse: boolean;
        notify: boolean;
        indicate: boolean;
        broadcast: boolean;
        authenticatedSignedWrites: boolean;
        extendedProperties: boolean;
    };
    descriptors: any;
    permissions: any;
}
export interface CRUDOptions {
    peripheralUUID: string;
    serviceUUID: string;
    characteristicUUID: string;
}
export interface ReadOptions extends CRUDOptions {
}
export interface WriteOptions extends CRUDOptions {
    value: any;
    encoding?: string;
}
export interface StopNotifyingOptions extends CRUDOptions {
}
export interface StartNotifyingOptions extends CRUDOptions {
    onNotify: (data: ReadResult) => void;
}
export interface ReadResult {
    value: any;
    ios?: any;
    android?: any;
    characteristicUUID: string;
}
export interface StartAdvertisingOptions {
    settings: any;
    UUID: any;
    data: any;
}
export interface IBluetoothEvents {
    error_event: string;
    bluetooth_enabled_event: string;
    peripheral_connected_event: string;
    bluetooth_advertise_success_event: string;
    bluetooth_advertise_failure_event: string;
    server_connection_state_changed_event: string;
    bond_status_change_event: string;
    device_discovered_event: string;
    device_name_change_event: string;
    device_uuid_change_event: string;
    device_acl_disconnected_event: string;
    characteristic_write_request_event: string;
    characteristic_read_request_event: string;
    descriptor_write_request_event: string;
    descriptor_read_request_event: string;
    execute_write_event: string;
}
