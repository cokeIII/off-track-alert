import { BluetoothCommon, ConnectOptions, Peripheral, ReadOptions, ReadResult, Service, StartNotifyingOptions, StartScanningOptions, StopNotifyingOptions, WriteOptions } from './bluetooth.common';
export declare class CBPeripheralDelegateImpl extends NSObject implements CBPeripheralDelegate {
    static ObjCProtocols: {
        prototype: CBPeripheralDelegate;
    }[];
    onReadCallbacks?: Array<(result: ReadResult) => void>;
    onWriteCallbacks?: Array<(result: {
        characteristicUUID: string;
    }) => void>;
    onNotifyCallback?: (result: ReadResult) => void;
    private _servicesWithCharacteristics;
    private _services;
    private _owner;
    private _callback;
    static new(): CBPeripheralDelegateImpl;
    initWithCallback(owner: WeakRef<Bluetooth>, callback: (result?) => void): CBPeripheralDelegateImpl;
    peripheralDidDiscoverServices(peripheral: CBPeripheral, error?: NSError): void;
    peripheralDidDiscoverIncludedServicesForServiceError(peripheral: CBPeripheral, service: CBService, error?: NSError): void;
    peripheralDidDiscoverCharacteristicsForServiceError(peripheral: CBPeripheral, service: CBService, error?: NSError): void;
    peripheralDidDiscoverDescriptorsForCharacteristicError(peripheral: CBPeripheral, characteristic: CBCharacteristic, error?: NSError): void;
    peripheralDidUpdateValueForCharacteristicError(peripheral: CBPeripheral, characteristic: CBCharacteristic, error?: NSError): void;
    peripheralDidUpdateValueForDescriptorError(peripheral: CBPeripheral, descriptor: CBDescriptor, error?: NSError): void;
    peripheralDidWriteValueForCharacteristicError(peripheral: CBPeripheral, characteristic: CBCharacteristic, error?: NSError): void;
    peripheralDidUpdateNotificationStateForCharacteristicError(peripheral: CBPeripheral, characteristic: CBCharacteristic, error?: NSError): void;
    peripheralDidWriteValueForDescriptorError(peripheral: CBPeripheral, descriptor: CBDescriptor, error?: NSError): void;
    private _getProperties(characteristic);
    private _getDescriptors(characteristic);
}
export declare class CBCentralManagerDelegateImpl extends NSObject implements CBCentralManagerDelegate {
    static ObjCProtocols: {
        prototype: CBCentralManagerDelegate;
    }[];
    private _owner;
    private _callback;
    static new(): CBCentralManagerDelegateImpl;
    initWithCallback(owner: WeakRef<Bluetooth>, callback: (result?) => void): CBCentralManagerDelegateImpl;
    centralManagerDidConnectPeripheral(central: CBCentralManager, peripheral: CBPeripheral): void;
    centralManagerDidDisconnectPeripheralError(central: CBCentralManager, peripheral: CBPeripheral, error?: NSError): void;
    centralManagerDidFailToConnectPeripheralError(central: CBCentralManager, peripheral: CBPeripheral, error?: NSError): void;
    centralManagerDidDiscoverPeripheralAdvertisementDataRSSI(central: CBCentralManager, peripheral: CBPeripheral, advData: NSDictionary<string, any>, RSSI: number): void;
    centralManagerDidUpdateState(central: CBCentralManager): void;
    centralManagerWillRestoreState(central: CBCentralManager, dict: NSDictionary<string, any>): void;
}
export declare class AdvertismentData {
    private advData;
    constructor(advData: NSDictionary<string, any>);
    readonly manufacturerData: ArrayBuffer;
    readonly data: ArrayBuffer;
    readonly manufacturerId: number;
    readonly txPowerLevel: any;
    readonly localName: any;
    readonly flags: number;
    readonly serviceUUIDs: any[];
    readonly overtflow: any[];
    readonly solicitedServices: any[];
    readonly connectable: any;
    readonly serviceData: {};
}
export declare function getBluetoothInstance(): Bluetooth;
export { Peripheral, ReadResult, Service };
export declare function toArrayBuffer(value: any): ArrayBuffer;
export declare function CBUUIDToString(uuid: CBUUID): string;
export declare class Bluetooth extends BluetoothCommon {
    private restoreIdentifier;
    private _centralDelegate;
    private _centralManager;
    _discoverPeripherals: {
        [k: string]: CBPeripheral;
    };
    _connectedPeripherals: {
        [k: string]: CBPeripheral;
    };
    _connectCallbacks: {};
    _disconnectCallbacks: {};
    _advData: {};
    _onDiscovered: any;
    _state: CBManagerState;
    state: CBManagerState;
    readonly centralManager: CBCentralManager;
    constructor(restoreIdentifier?: string);
    _getState(state: CBPeripheralState): "connecting" | "connected" | "disconnected";
    private prepareConnectedPeripheralDelegate(peripheral);
    onPeripheralDisconnected(peripheral: CBPeripheral): void;
    onPeripheralConnected(peripheral: CBPeripheral): void;
    isBluetoothEnabled(): Promise<boolean>;
    scanningReferTimer: {
        timer?: number;
        resolve?: Function;
    };
    startScanning(arg: StartScanningOptions): Promise<{}>;
    enable(): Promise<boolean>;
    isGPSEnabled(): Promise<boolean>;
    enableGPS(): Promise<void>;
    openBluetoothSettings(url?: string): Promise<void>;
    stopScanning(): Promise<{}>;
    connect(args: ConnectOptions): Promise<void>;
    disconnect(args: any): Promise<void>;
    isConnected(args: any): Promise<boolean>;
    findPeripheral: (UUID: any) => CBPeripheral;
    adddDiscoverPeripheral: (peripheral: any) => void;
    findDiscoverPeripheral: (UUID: any) => CBPeripheral;
    read(args: ReadOptions): Promise<{}>;
    write(args: WriteOptions): Promise<{}>;
    writeWithoutResponse(args: WriteOptions): Promise<never>;
    startNotifying(args: StartNotifyingOptions): Promise<never>;
    stopNotifying(args: StopNotifyingOptions): Promise<never>;
    private _isEnabled();
    private _findService(UUID, peripheral);
    private _findCharacteristic(UUID, service, property?);
    private _getWrapper(args, property);
    private nativeEncoding(encoding);
    private valueToNSData(value, encoding?);
    private valueToString(value);
}
